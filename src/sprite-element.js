import * as css from "./css";

/**
 * Class representing the UI Element of the sprite.
 * Each Sprite has one.
 * @private
 */
export default class SpriteElement {
    /**
     * constructor - Creates a Sprite Element.
     *
     * @param {object} sprite - the sprite for which the element is created.
     * @param {object} stage - the stage to which the sprite is added.
     */
    constructor(sprite, stage) {
        const el = document.createElement("div");

        el.id = `${sprite.id}`;
        el.style.position = "absolute";
        el.style.touchAction = "manipulation";

        stage.element.el.appendChild(el);

        this.el = el;
    }

    /**
     * update - updates the DOM element. This is always called after the constructor.
     *
     * @param {import("./sprite").default} sprite - the sprite to update.
     */
    update(sprite) {
        const el = sprite.element.el;
        // Convert the center based x coordinate to a left based one.
        const x = sprite.x - sprite.width / 2;
        // Convert the center based y coordinate to a left based one.
        const y = -sprite.y - sprite.height / 2;

        // Costume
        if (sprite.costume) {
            el.style.width = `${sprite.costume.visibleWidth}px`;
            el.style.height = `${sprite.costume.visibleHeight}px`;
        }

        el.style.filter = sprite.getCSSFilter();
        el.style.left = `${sprite.stage.width / 2 + x}px`;
        el.style.top = `${sprite.stage.height / 2 + y}px`;
        el.style.zIndex = sprite.z;

        el.style.visibility = `${sprite.showing ? "visible" : "hidden"}`;

        // Left or right rotation
        // Direction divided by 180 and floored -> 1 or 2.
        // Subtract 1 -> 0 or 1.
        // Multiply by -1 -> 0 or -1.
        // Css transform -> None or full X.
        sprite.rotationStyle === 1
            ? (el.style.transform = `scaleX(${
                  (Math.floor(sprite.direction / 180) * 2 - 1) * -1
              })`)
            : null;

        // Full rotation
        // Sprite "neutral position" is 90. CSS is 0. Subtract 90.
        // Normalize to 360.
        // Css rotate -> Number of degrees.
        sprite.rotationStyle === 0
            ? (el.style.transform = `rotate(${
                  (sprite.direction - 90 + 360) % 360
              }deg)`)
            : null;

        // CSS rules classes and the background color.
        // The costume color setting overrides any CSS setting.

        // There is no color property to current costume - so reset the background-color property of the element.
        !sprite.costume || !sprite.costume.color
            ? (el.style.backgroundColor = "")
            : null;

        // apply CSS rules (may include background color)
        css.apply(sprite);

        // apply CSS classes
        sprite.costume
            ? (el.className = sprite.costume.classes
                  .concat(sprite.classes)
                  .join(" "))
            : (el.className = sprite.classes.join(" "));

        // There is a color property to current costume - so apply it and override CSS rules.
        sprite.costume && sprite.costume.color
            ? (el.style.backgroundColor = sprite.costume.color)
            : null;

        // Image.
        if (sprite.costume && el.firstChild) {
            // has image from previous costume
            if (!sprite.costume.image) {
                // needs removed as there is no image in current costume.
                el.removeChild(el.firstChild);
            } else if (sprite.costume.image !== this.el.firstChild.src) {
                // needs replaced
                this.el.firstChild.src = sprite.costume.image;
            }
        } else if (sprite.costume && sprite.costume.image) {
            // needs an image inserted.
            const image = new Image();

            image.style.width = "100%";
            image.style.height = "100%";
            image.style.position = "absolute";
            image.src = sprite.costume.image;
            el.appendChild(image);
        }

        el.firstChild ? (el.firstChild.draggable = false) : null;

        // Inner. Must by done after the image
        sprite.costume && sprite.costume.innerHTML
            ? (el.innerHTML = sprite.costume.innerHTML)
            : null;

        // Text UI goes where sprite goes.
        sprite.textui ? sprite.textui.update(sprite) : null;

        this.el = el;
    }

    /**
     * delete - deletes the DOM element.
     *
     * @param {object} sprite - the sprite to delete.
     */
    delete(sprite) {
        const el = sprite.element.el;

        el.parentNode.removeChild(el);
        return null;
    }

    /**
     * addFlag - puts the flag div infront of everything (shows it).
     *
     * @param {object} sprite - the sprite that "requested" the flag.
     */
    addFlag(sprite) {
        const el = sprite.element.flag;

        el.style.zIndex = 1000;
        el.style.display = "block";
    }

    /**
     * removeFlag - puts the flag div at the back (hides it).
     *
     * @param {object} sprite - the sprite that "requested" the flag.
     */
    removeFlag(sprite) {
        const el = sprite.element.flag;

        el.style.zIndex = -1;
        el.style.display = "none";
    }
}
